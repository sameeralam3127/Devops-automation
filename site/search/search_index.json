{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Compute Central","text":"<p>Welcome to Compute Central, your go-to destination for DevOps and SRE tools, tips, tricks, and community-driven forums! </p> <p>Since 2016, we have been committed to sharing valuable insights, tutorials, and resources to help developers and operations teams improve their workflow, enhance system reliability, and stay up to date with the latest trends in the tech world.</p>"},{"location":"#what-you-will-find-here","title":"What You Will Find Here","text":"<ul> <li>DevOps Tips and Best Practices: Learn about the latest tools and techniques to streamline your DevOps pipelines and optimize your CI/CD workflows.</li> <li>SRE Tools: Discover tools and methods for Site Reliability Engineering (SRE), and how to implement them to improve service reliability.</li> <li>Tutorials and Guides: Step-by-step tutorials to help you set up and use various DevOps and SRE tools.</li> <li>Community Forums: Engage with the community and share your thoughts on best practices, challenges, and new tools.</li> </ul>"},{"location":"#about-me","title":"About Me","text":"<p>I am Sameer Alam, a passionate DevOps engineer and site reliability advocate. I have spent years exploring various tools and strategies for better system management, and I now share my experiences and insights on this blog. You can explore my work and contributions on GitHub:</p> <p>My GitHub Profile</p>"},{"location":"#blog-archive","title":"Blog Archive","text":"<p>Explore the articles from my old Blogger blog, which was started in 2016. You can still access the older content here:</p> <p>Old Blog Archive</p> <p>Feel free to explore and get in touch if you have any questions or feedback. Happy learning!</p>"},{"location":"docker/docker/","title":"Containerization techniques","text":""},{"location":"docker/docker/#docker-command-cheat-sheet","title":"Docker Command Cheat Sheet","text":""},{"location":"docker/docker/#basic-commands","title":"Basic Commands","text":"<ul> <li> <p>Check Docker Version <code>bash   docker --version</code></p> </li> <li> <p>List Docker Images <code>bash   docker images</code></p> </li> <li> <p>List Running Containers <code>bash   docker ps</code></p> </li> <li> <p>List All Containers (including stopped) <code>bash   docker ps -a</code></p> </li> <li> <p>Run a Container <code>bash   docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p> </li> <li> <p>Stop a Running Container <code>bash   docker stop CONTAINER_ID</code></p> </li> <li> <p>Remove a Container <code>bash   docker rm CONTAINER_ID</code></p> </li> <li> <p>Remove an Image <code>bash   docker rmi IMAGE_ID</code></p> </li> </ul>"},{"location":"docker/docker/#building-docker-images","title":"Building Docker Images","text":"<ul> <li> <p>Build an Image from a Dockerfile <code>bash   docker build -t IMAGE_NAME:TAG PATH</code></p> </li> <li> <p>Build an Image from a Dockerfile (No Cache) <code>bash   docker build --no-cache -t IMAGE_NAME:TAG PATH</code></p> </li> <li> <p>View Build History <code>bash   docker history IMAGE_NAME:TAG</code></p> </li> </ul>"},{"location":"docker/docker/#dockerfile-basics","title":"Dockerfile Basics","text":"<ul> <li>Basic Dockerfile Structure   ```Dockerfile   # Use a base image   FROM ubuntu:latest</li> </ul> <p># Set environment variables   ENV VAR_NAME=value</p> <p># Install dependencies   RUN apt-get update &amp;&amp; apt-get install -y package</p> <p># Add files to the image   COPY local_path /container_path</p> <p># Set the working directory   WORKDIR /container_path</p> <p># Define the command to run   CMD [\"executable\", \"param1\", \"param2\"]   ```</p>"},{"location":"docker/docker/#networking-and-volumes","title":"Networking and Volumes","text":"<ul> <li> <p>Create a Network <code>bash   docker network create NETWORK_NAME</code></p> </li> <li> <p>Run a Container with a Network <code>bash   docker run --network NETWORK_NAME IMAGE_NAME</code></p> </li> <li> <p>Create a Volume <code>bash   docker volume create VOLUME_NAME</code></p> </li> <li> <p>Run a Container with a Volume <code>bash   docker run -v VOLUME_NAME:/container_path IMAGE_NAME</code></p> </li> </ul>"},{"location":"docker/docker/#docker-compose","title":"Docker Compose","text":"<ul> <li> <p>Start Services <code>bash   docker-compose up</code></p> </li> <li> <p>Start Services in Detached Mode <code>bash   docker-compose up -d</code></p> </li> <li> <p>Stop Services <code>bash   docker-compose down</code></p> </li> <li> <p>Build Services <code>bash   docker-compose build</code></p> </li> <li> <p>View Logs <code>bash   docker-compose logs</code></p> </li> </ul>"},{"location":"docker/docker/#pipeline-commands","title":"Pipeline Commands","text":"<ul> <li> <p>Push Image to Registry <code>bash   docker push IMAGE_NAME:TAG</code></p> </li> <li> <p>Pull Image from Registry <code>bash   docker pull IMAGE_NAME:TAG</code></p> </li> <li> <p>Tag an Image <code>bash   docker tag SOURCE_IMAGE:TAG TARGET_IMAGE:TAG</code></p> </li> <li> <p>Login to Docker Hub <code>bash   docker login</code></p> </li> <li> <p>Logout from Docker Hub <code>bash   docker logout</code></p> </li> </ul>"},{"location":"kubernetes/kubernetes/","title":"Mastering Kubernetes: From Introduction to Deploying NGINX","text":"<p>Kubernetes is a powerful tool that helps manage and run applications in containers. It makes tasks like deploying, scaling, and maintaining apps much easier. This guide will help you learn the basics of Kubernetes, set it up in Docker Desktop, use <code>kubectl</code>, and deploy NGINX.</p>"},{"location":"kubernetes/kubernetes/#what-is-kubernetes","title":"What is Kubernetes?","text":"<p>Kubernetes is a free, open-source system that helps automate the management of applications in containers. It simplifies the deployment and operation of applications by handling the underlying infrastructure for you. Here\u2019s a quick look at its main features:</p>"},{"location":"kubernetes/kubernetes/#key-concepts","title":"Key Concepts","text":"<ol> <li>Pod:</li> <li>What It Is: The smallest unit in Kubernetes. A Pod can hold one or more containers that share the same network and storage.</li> <li> <p>What It Does: Runs single instances of applications or services, keeping them consistent and separate from others.</p> </li> <li> <p>Deployment:</p> </li> <li>What It Is: Manages how Pods are deployed and scaled. It ensures that the right number of Pods are running and helps with updates.</li> <li> <p>What It Does: Automates creating, updating, and scaling Pods, making sure your app is always available.</p> </li> <li> <p>Service:</p> </li> <li>What It Is: Defines a way to access a set of Pods and provides a stable network address.</li> <li> <p>What It Does: Helps with load balancing and finding services, ensuring reliable communication between app parts.</p> </li> <li> <p>ReplicaSet:</p> </li> <li>What It Is: Ensures a specified number of Pod copies are running. Usually managed by Deployments.</li> <li> <p>What It Does: Keeps your app reliable and scalable by maintaining the right number of Pod copies.</p> </li> <li> <p>Namespace:</p> </li> <li>What It Is: Divides cluster resources into virtual clusters to organize and control access.</li> <li>What It Does: Useful for separating environments like development and production, or for managing different projects.</li> </ol>"},{"location":"kubernetes/kubernetes/#setting-up-kubernetes-in-docker-desktop","title":"Setting Up Kubernetes in Docker Desktop","text":"<p>Docker Desktop includes a built-in Kubernetes cluster for local development. Here\u2019s how to set it up:</p> <ol> <li>Open Docker Desktop:</li> <li> <p>Start Docker Desktop from your applications menu.</p> </li> <li> <p>Go to Settings:</p> </li> <li> <p>Click the gear icon (\u2699\ufe0f) in the top-right corner.</p> </li> <li> <p>Select the Kubernetes Tab:</p> </li> <li> <p>Choose the \"Kubernetes\" tab from the sidebar.</p> </li> <li> <p>Enable Kubernetes:</p> </li> <li> <p>Check \"Enable Kubernetes\".</p> </li> <li> <p>Apply &amp; Restart:</p> </li> <li> <p>Click \"Apply &amp; Restart\" to start Kubernetes. Docker Desktop will restart to configure it.</p> </li> <li> <p>Wait for Setup:</p> </li> <li>It might take a few minutes for Kubernetes to start. Docker Desktop will show the setup status.</li> </ol>"},{"location":"kubernetes/kubernetes/#what-is-kubectl","title":"What is <code>kubectl</code>?","text":"<p><code>kubectl</code> is a command-line tool for managing Kubernetes clusters. It lets you interact with your Kubernetes resources.</p>"},{"location":"kubernetes/kubernetes/#key-features-of-kubectl","title":"Key Features of <code>kubectl</code>:","text":"<ul> <li>Run Commands: Manage resources like Pods, Services, and Deployments.</li> <li>Change Configurations: Apply changes to create or update resources.</li> <li>Check Status: View and debug the state of resources in the cluster.</li> </ul>"},{"location":"kubernetes/kubernetes/#common-kubectl-commands","title":"Common <code>kubectl</code> Commands:","text":"<ul> <li>Get Resources:   <code>bash   kubectl get [resource]</code></li> <li> <p>Lists resources like Pods, Services, or Deployments.</p> </li> <li> <p>Describe Resource:   <code>bash   kubectl describe [resource] [name]</code></p> </li> <li> <p>Shows detailed info about a specific resource.</p> </li> <li> <p>Apply Configuration:   <code>bash   kubectl apply -f [file.yaml]</code></p> </li> <li> <p>Applies changes from a YAML file.</p> </li> <li> <p>Delete Resource:   <code>bash   kubectl delete -f [file.yaml]</code></p> </li> <li>Deletes resources from the cluster. -If you want to delete all the pods in a namespace, use:</li> </ul> <pre><code>kubectl delete pods --all\n</code></pre> <p>-To delete all services in the current namespace, use:</p> <pre><code>kubectl delete services --all\n</code></pre>"},{"location":"kubernetes/kubernetes/#checking-versions","title":"Checking Versions","text":""},{"location":"kubernetes/kubernetes/#check-kubectl-version","title":"Check <code>kubectl</code> Version","text":"<p>To find out which version of <code>kubectl</code> you have:</p> <pre><code>kubectl version --client\n</code></pre> <pre><code>kubectl version\n</code></pre> <ul> <li>This shows both the client and server versions of Kubernetes.</li> </ul>"},{"location":"kubernetes/kubernetes/#deploying-nginx-instances","title":"Deploying NGINX Instances","text":"<p>To deploy multiple NGINX instances, follow these steps:</p>"},{"location":"kubernetes/kubernetes/#step-1-create-a-deployment","title":"Step 1: Create a Deployment","text":"<ol> <li>Open Terminal:</li> <li> <p>Use your terminal or command prompt.</p> </li> <li> <p>Create Deployment YAML File:</p> </li> <li>Save the following to <code>nginx-deployment.yaml</code>:</li> </ol> <p><code>yaml    apiVersion: apps/v1    kind: Deployment    metadata:      name: nginx-deployment    spec:      replicas: 3      selector:        matchLabels:          app: nginx      template:        metadata:          labels:            app: nginx        spec:          containers:          - name: nginx            image: nginx:latest            ports:            - containerPort: 80</code></p> <ul> <li> <p>What It Does: Defines a Deployment with 3 replicas of NGINX.</p> </li> <li> <p>Apply the Deployment:</p> </li> <li>Run:</li> </ul> <p><code>bash    kubectl apply -f nginx-deployment.yaml</code></p>"},{"location":"kubernetes/kubernetes/#step-2-expose-the-deployment","title":"Step 2: Expose the Deployment","text":"<ol> <li>Create Service YAML File:</li> <li>Save the following to <code>nginx-service.yaml</code>:</li> </ol> <p><code>yaml    apiVersion: v1    kind: Service    metadata:      name: nginx-service    spec:      selector:        app: nginx      ports:        - protocol: TCP          port: 80          targetPort: 80      type: LoadBalancer</code></p> <ul> <li> <p>What It Does: Creates a Service to expose the NGINX Deployment.</p> </li> <li> <p>Apply the Service:</p> </li> <li>Run:</li> </ul> <p><code>bash    kubectl apply -f nginx-service.yaml</code></p> <ol> <li>Access NGINX in Browser:</li> <li>Open:</li> </ol> <p><code>bash    http://127.0.0.1/</code></p>"},{"location":"kubernetes/kubernetes/#step-3-check-the-status","title":"Step 3: Check the Status","text":"<ol> <li>List Pods:</li> <li>Check Pods:</li> </ol> <p><code>bash    kubectl get pods</code></p> <ol> <li>Check Deployment:</li> <li>Verify Deployment:</li> </ol> <p><code>bash    kubectl get deployments</code></p> <ol> <li>Check Service:</li> <li>View Service status:</li> </ol> <p><code>bash    kubectl get services</code></p> <ul> <li>Note: Docker Desktop has a Kubernetes dashboard for a visual view of your resources.</li> </ul>"},{"location":"kubernetes/kubernetes/#step-4-clean-up","title":"Step 4: Clean Up","text":"<ol> <li>Delete the Service:</li> </ol> <p><code>bash    kubectl delete -f nginx-service.yaml</code></p> <ol> <li>Delete the Deployment:</li> </ol> <p><code>bash    kubectl delete -f nginx-deployment.yaml</code></p> <ol> <li>Verify Deletion:</li> <li>Ensure Pods and Services are removed:</li> </ol> <p><code>bash    kubectl get pods    kubectl get services</code></p>"},{"location":"kubernetes/service-discovery/","title":"Service discovery","text":"<p>Shell script that automates the installation of <code>kubectl</code>, <code>minikube</code>, and <code>docker</code> on Ubuntu 22.04 (Jammy Jellyfish):</p> <pre><code>#!/bin/bash\n\n# Update system packages\nsudo apt-get update -y\nsudo apt-get upgrade -y\n\n# Install Docker\nsudo apt-get remove docker docker-engine docker.io containerd runc -y\nsudo apt-get update -y\nsudo apt-get install ca-certificates curl gnupg lsb-release -y\n\n# Add Docker's official GPG key\nsudo mkdir -m 0755 -p /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n# Set up the Docker repository\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n# Install Docker Engine\nsudo apt-get update -y\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y\n\n# Start and enable Docker\nsudo systemctl start docker\nsudo systemctl enable docker\n\n# Add your user to the docker group\nsudo usermod -aG docker $USER\n\n# Install kubectl\nsudo apt-get update -y\nsudo apt-get install -y apt-transport-https ca-certificates curl\nsudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg\necho \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list\nsudo apt-get update -y\nsudo apt-get install -y kubectl\n\n# Install Minikube\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\nrm minikube-linux-amd64\n\n# Print installation versions\necho \"Docker version:\"\ndocker --version\necho \"kubectl version:\"\nkubectl version --client\necho \"Minikube version:\"\nminikube version\n\necho \"Installation complete. Please log out and log back in to apply the Docker group membership.\"\n</code></pre>"},{"location":"kubernetes/service-discovery/#instructions-to-run-the-script","title":"Instructions to Run the Script","text":"<ol> <li>Save the script to a file, for example <code>install_k8s_tools.sh</code>.</li> <li>Make the script executable:     <code>bash     chmod +x install_k8s_tools.sh</code></li> <li>Run the script:     <code>bash     ./install_k8s_tools.sh</code></li> </ol> <p>This script will:</p> <ul> <li>Update and upgrade the system packages.</li> <li>Install Docker and add the current user to the <code>docker</code> group.</li> <li>Install <code>kubectl</code> from the Kubernetes APT repository.</li> <li>Install the latest version of <code>minikube</code>.</li> </ul> <p>After running the script, log out and log back in to apply the Docker group membership changes.  </p>"},{"location":"shell-scripts/handy-scripts/","title":"SSL Certificate Installation","text":"<pre><code>#!/bin/bash\n\n# Function to check if the OS is RHEL or Debian-based\ndetect_os() {\n    if [ -f /etc/redhat-release ]; then\n        OS=\"RHEL\"\n    elif [ -f /etc/debian_version ]; then\n        OS=\"Debian\"\n    else\n        echo \"Unsupported OS\"\n        exit 1\n    fi\n}\n\n# Function to check and install Certbot\ninstall_certbot() {\n    echo \"Checking if Certbot is installed...\"\n\n    if command -v certbot &amp;&gt; /dev/null; then\n        echo \"Certbot is already installed.\"\n        return\n    fi\n\n    echo \"Certbot not found. Installing Certbot...\"\n\n    if [ \"$OS\" == \"Debian\" ]; then\n        apt-get update\n        apt-get install -y certbot\n    elif [ \"$OS\" == \"RHEL\" ]; then\n        yum install -y epel-release\n        yum install -y certbot\n    else\n        echo \"Unsupported OS for Certbot installation\"\n        exit 1\n    fi\n}\n\n# Function to check the existing SSL certificate details\ncheck_existing_ssl() {\n    echo \"Checking existing SSL certificates for HTTPD and NGINX...\"\n\n    for config_file in /etc/httpd/conf.d/ssl.conf /etc/nginx/nginx.conf; do\n        if [ -f \"$config_file\" ]; then\n            echo \"SSL Configuration found in: $config_file\"\n            ssl_cert=$(grep -i \"SSLCertificateFile\\|ssl_certificate\" $config_file | awk '{print $2}')\n            if [ -f \"$ssl_cert\" ]; then\n                echo \"SSL Certificate Details:\"\n                openssl x509 -in $ssl_cert -noout -text | grep -E 'Issuer:|Subject:|Not After :'\n            else\n                echo \"SSL Certificate not found in the specified location: $ssl_cert\"\n            fi\n        else\n            echo \"SSL configuration file not found for $config_file\"\n        fi\n    done\n}\n\n# Function to create a private key and CSR\ncreate_key_and_csr() {\n    echo \"Creating Private Key and CSR...\"\n    mkdir -p /certs\n\n    read -p \"Enter Country (2 letter code): \" country\n    read -p \"Enter State or Province Name: \" state\n    read -p \"Enter Locality Name (e.g., city): \" locality\n    read -p \"Enter Organization Name: \" organization\n    read -p \"Enter Organizational Unit Name: \" unit\n    read -p \"Enter Common Name (e.g., domain name): \" common_name\n    read -p \"Enter Email Address: \" email\n\n    if [ -z \"$common_name\" ]; then\n        echo \"Error: Common Name (domain) is required.\"\n        exit 1\n    fi\n\n    openssl req -newkey rsa:2048 -nodes -keyout /certs/mydomain.key -out /certs/mydomain.csr -subj \"/C=$country/ST=$state/L=$locality/O=$organization/OU=$unit/CN=$common_name/emailAddress=$email\"\n    if [ $? -ne 0 ]; then\n        echo \"Error creating CSR\"\n        exit 1\n    fi\n    echo \"Private key and CSR created successfully.\"\n}\n\n# Function to obtain a certificate using Let's Encrypt\ncreate_ssl_certificate() {\n    echo \"Generating SSL certificate using Let's Encrypt...\"\n\n    install_certbot\n\n    certbot certonly --standalone --non-interactive --agree-tos --email $email -d $common_name\n    if [ $? -ne 0 ]; then\n        echo \"Error generating SSL certificate\"\n        exit 1\n    fi\n    echo \"SSL certificate generated successfully.\"\n}\n\n# Function to move certificate and key to correct locations for HTTPD and NGINX\ninstall_certificate() {\n    echo \"Installing SSL certificate for HTTPD and NGINX...\"\n    mkdir -p /etc/httpd/ssl /etc/nginx/ssl\n\n    mv /etc/letsencrypt/live/$common_name/fullchain.pem /etc/httpd/ssl/mydomain.crt\n    mv /etc/letsencrypt/live/$common_name/privkey.pem /etc/httpd/ssl/mydomain.key\n    mv /etc/letsencrypt/live/$common_name/fullchain.pem /etc/nginx/ssl/mydomain.crt\n    mv /etc/letsencrypt/live/$common_name/privkey.pem /etc/nginx/ssl/mydomain.key\n\n    # Set permissions\n    chmod 600 /etc/httpd/ssl/mydomain.key\n    chown root:root /etc/httpd/ssl/mydomain.key\n    chmod 644 /etc/httpd/ssl/mydomain.crt\n    chown root:root /etc/httpd/ssl/mydomain.crt\n    chmod 600 /etc/nginx/ssl/mydomain.key\n    chown root:root /etc/nginx/ssl/mydomain.key\n    chmod 644 /etc/nginx/ssl/mydomain.crt\n    chown root:root /etc/nginx/ssl/mydomain.crt\n\n    # Update HTTPD conf\n    if grep -q \"SSLCertificateFile\" /etc/httpd/conf.d/ssl.conf; then\n        sed -i \"s#SSLCertificateFile .*#SSLCertificateFile /etc/httpd/ssl/mydomain.crt#\" /etc/httpd/conf.d/ssl.conf\n        sed -i \"s#SSLCertificateKeyFile .*#SSLCertificateKeyFile /etc/httpd/ssl/mydomain.key#\" /etc/httpd/conf.d/ssl.conf\n    else\n        echo \"SSLCertificateFile /etc/httpd/ssl/mydomain.crt\" &gt;&gt; /etc/httpd/conf.d/ssl.conf\n        echo \"SSLCertificateKeyFile /etc/httpd/ssl/mydomain.key\" &gt;&gt; /etc/httpd/conf.d/ssl.conf\n    fi\n\n    # Update NGINX conf\n    if grep -q \"ssl_certificate\" /etc/nginx/nginx.conf; then\n        sed -i \"s#ssl_certificate .*#ssl_certificate /etc/nginx/ssl/mydomain.crt;#\" /etc/nginx/nginx.conf\n        sed -i \"s#ssl_certificate_key .*#ssl_certificate_key /etc/nginx/ssl/mydomain.key;#\" /etc/nginx/nginx.conf\n    else\n        echo \"ssl_certificate /etc/nginx/ssl/mydomain.crt;\" &gt;&gt; /etc/nginx/nginx.conf\n        echo \"ssl_certificate_key /etc/nginx/ssl/mydomain.key;\" &gt;&gt; /etc/nginx/nginx.conf\n    fi\n\n    systemctl restart httpd nginx\n\n    if [ $? -ne 0 ]; then\n        echo \"Error restarting services. Checking logs...\"\n        if [ \"$OS\" == \"RHEL\" ]; then\n            cat /var/log/httpd/error_log /var/log/nginx/error.log\n        else\n            cat /var/log/apache2/error.log /var/log/nginx/error.log\n        fi\n        exit 1\n    fi\n\n    echo \"SSL Certificate installed and services restarted successfully.\"\n}\n\n# Function to renew SSL certificate\nrenew_certificate() {\n    echo \"Renewing SSL certificate...\"\n    certbot renew\n    if [ $? -ne 0 ]; then\n        echo \"Error renewing SSL certificate.\"\n        exit 1\n    fi\n    install_certificate\n}\n\n# Function to validate HTTPS connection\nvalidate_https() {\n    echo \"Validating HTTPS connection on port 443...\"\n    curl -Is https://$common_name:443 | head -n 1\n    if [ $? -ne 0 ]; then\n        echo \"Error: Unable to connect to $common_name on port 443.\"\n        exit 1\n    fi\n    echo \"HTTPS validation successful.\"\n}\n\n# Menu-driven interface\nwhile true; do\n    echo \"SSL Certificate Management Script\"\n    echo \"1. Check Existing SSL Certificate\"\n    echo \"2. Create Key and CSR\"\n    echo \"3. Generate SSL Certificate (Let's Encrypt)\"\n    echo \"4. Install Certificate\"\n    echo \"5. Renew SSL Certificate\"\n    echo \"6. Validate HTTPS Connection\"\n    echo \"7. Exit\"\n\n    read -p \"Enter your choice: \" choice\n\n    case $choice in\n        1) check_existing_ssl ;;\n        2) create_key_and_csr ;;\n        3) create_ssl_certificate ;;\n        4) install_certificate ;;\n        5) renew_certificate ;;\n        6) validate_https ;;\n        7) echo \"Exiting...\"; exit ;;\n        *) echo \"Invalid choice. Please select a valid option.\" ;;\n    esac\ndone\n</code></pre>"}]}