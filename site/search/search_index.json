{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DevOps Automation Knowledge Hub","text":"<p>Welcome to the DevOps Automation Knowledge Hub! This repository is designed to share comprehensive DevOps knowledge, tools, and automation techniques. Whether you're new to DevOps or looking to enhance your expertise, this collection covers everything you need to build, deploy, and manage applications efficiently.</p> <p>This repository includes a complete solution for DevOps automation, covering:</p>"},{"location":"#1-docker","title":"1. Docker","text":"<ul> <li>Containerization techniques.</li> <li>Dockerfile best practices.</li> <li>Docker Compose for multi-container applications.</li> </ul>"},{"location":"#2-kubernetes","title":"2. Kubernetes","text":"<ul> <li>Managing containerized applications in Kubernetes clusters.</li> <li>Helm charts for Kubernetes deployments.</li> <li>Kubernetes service discovery and networking.</li> </ul>"},{"location":"#3-jenkins","title":"3. Jenkins","text":"<ul> <li>Automating CI/CD pipelines with Jenkins.</li> <li>Setting up Jenkins pipelines using declarative syntax.</li> <li>Integrating Jenkins with version control systems (e.g., Git).</li> </ul>"},{"location":"#4-sonarqube","title":"4. SonarQube","text":"<ul> <li>Implementing continuous inspection of code quality.</li> <li>Integrating SonarQube with Jenkins and other CI/CD tools.</li> <li>Customizing quality gates and code analysis rules.</li> </ul>"},{"location":"#5-cicd-tools","title":"5. CI/CD Tools","text":"<ul> <li>Full CI/CD pipeline examples.</li> <li>Integrating testing, building, and deployment stages.</li> <li>Using GitLab CI, Jenkins, and other CI/CD tools to automate delivery pipelines.</li> </ul>"},{"location":"#6-shell-scripts","title":"6. Shell Scripts","text":"<ul> <li>Handy scripts to automate routine tasks.</li> <li>Deployment automation and server management.</li> <li>System monitoring and health checks.</li> </ul>"},{"location":"#7-ansible","title":"7. Ansible","text":"<ul> <li>Automating infrastructure management and provisioning.</li> <li>Writing Ansible playbooks for configuration management.</li> <li>Dynamic inventory and role-based automation solutions.</li> </ul>"},{"location":"#how-to-use-this-repository","title":"How to Use This Repository","text":"<p>Each section contains detailed documentation, example scripts, and configurations for real-world DevOps environments. Start with any section to get familiar with the tool, or combine them to implement a complete DevOps automation workflow.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>Feel free to contribute by adding new tools, enhancing existing scripts, or sharing your knowledge to help others in the DevOps community.</p>"},{"location":"#license","title":"License","text":"<p>This repository is open-sourced under the MIT License.</p> <p>Happy automating!</p>"},{"location":"Ansible/WSL/","title":"How to Set Up an Ansible Environment on a Windows Laptop","text":"<p>Setting up Ansible on a Windows machine can seem tricky since Ansible is primarily designed to run on Linux or Unix-based systems. However, with a few easy steps, you can create a working environment for Ansible on your Windows laptop using Windows Subsystem for Linux (WSL) or a virtual environment such as VirtualBox. In this blog, I'll guide you through setting up Ansible using WSL.</p>"},{"location":"Ansible/WSL/#what-is-ansible","title":"What Is Ansible?","text":"<p>Ansible is an open-source automation tool that simplifies cloud provisioning, configuration management, application deployment, and other IT processes. It enables you to automate tasks with ease and reduces manual effort significantly, making it a powerful tool for DevOps engineers and system administrators.</p>"},{"location":"Ansible/WSL/#why-use-wsl-for-ansible","title":"Why Use WSL for Ansible?","text":"<p>Windows Subsystem for Linux (WSL) allows you to run a Linux distribution directly on your Windows machine without needing to install a separate Linux OS. It is perfect for running command-line tools like Ansible.</p>"},{"location":"Ansible/WSL/#prerequisites","title":"Prerequisites","text":"<p>Before we begin, here are the things you need:</p> <ol> <li>A Windows laptop with Windows 10 version 2004 or later.</li> <li>Basic knowledge of the command line.</li> <li>Administrative privileges on your machine.</li> </ol> <p>Now, let\u2019s get started!</p>"},{"location":"Ansible/WSL/#step-1-install-wsl-windows-subsystem-for-linux","title":"Step 1: Install WSL (Windows Subsystem for Linux)","text":""},{"location":"Ansible/WSL/#11-enable-wsl","title":"1.1 Enable WSL","text":"<p>The first step is to enable the WSL feature on your Windows laptop. Open PowerShell as Administrator and run the following command:</p> <pre><code>wsl --install\n</code></pre> <p>This will install WSL and the default Linux distribution, which is Ubuntu. If you already have WSL installed, you can update to WSL 2 by running:</p> <pre><code>wsl --set-default-version 2\n</code></pre>"},{"location":"Ansible/WSL/#12-verify-wsl-installation","title":"1.2 Verify WSL Installation","text":"<p>Once the installation is done, you can verify if WSL is installed correctly by opening the Command Prompt or PowerShell and typing:</p> <pre><code>wsl --list --verbose\n</code></pre> <p>This command will show you the installed Linux distributions and their versions.</p>"},{"location":"Ansible/WSL/#step-2-install-ubuntu-from-the-microsoft-store","title":"Step 2: Install Ubuntu from the Microsoft Store","text":"<p>Once WSL is installed, you need to install a Linux distribution. The most common one is Ubuntu.</p> <ol> <li>Go to the Microsoft Store and search for \u201cUbuntu\u201d.</li> <li>Select the version you want (the latest one is preferable) and click Install.</li> <li>After the installation, launch Ubuntu from the Start Menu. The first time you open it, you'll be prompted to create a username and password for your WSL environment.</li> </ol>"},{"location":"Ansible/WSL/#step-3-update-and-upgrade-ubuntu","title":"Step 3: Update and Upgrade Ubuntu","text":"<p>Now that you have Ubuntu running on your Windows laptop, update the package lists and install any available upgrades to make sure your system is up to date.</p> <p>Open your Ubuntu terminal and run the following commands:</p> <pre><code>sudo apt update\nsudo apt upgrade -y\n</code></pre> <p>This ensures that you have the latest software and security patches.</p>"},{"location":"Ansible/WSL/#step-4-install-ansible","title":"Step 4: Install Ansible","text":"<p>With Ubuntu set up, installing Ansible is straightforward. You can install it using the apt package manager.</p>"},{"location":"Ansible/WSL/#41-add-the-ansible-ppa","title":"4.1 Add the Ansible PPA","text":"<p>First, you\u2019ll need to add the official Ansible repository to your system. Run this command:</p> <pre><code>sudo apt-add-repository --yes --update ppa:ansible/ansible\n</code></pre>"},{"location":"Ansible/WSL/#42-install-ansible","title":"4.2 Install Ansible","text":"<p>After adding the repository, install Ansible with the following command:</p> <pre><code>sudo apt install ansible -y\n</code></pre>"},{"location":"Ansible/WSL/#43-verify-ansible-installation","title":"4.3 Verify Ansible Installation","text":"<p>You can verify that Ansible is installed correctly by checking the version:</p> <pre><code>ansible --version\n</code></pre> <p>If Ansible is successfully installed, you should see the version and configuration details.</p>"},{"location":"Ansible/WSL/#step-5-test-ansible","title":"Step 5: Test Ansible","text":"<p>Now that Ansible is installed, let's create a simple playbook to test if everything is working.</p>"},{"location":"Ansible/WSL/#51-create-a-simple-playbook","title":"5.1 Create a Simple Playbook","text":"<p>Create a new file called <code>test-playbook.yml</code>:</p> <pre><code>nano test-playbook.yml\n</code></pre> <p>Add the following content to the file:</p> <pre><code>---\n- hosts: localhost\n  tasks:\n    - name: Test ping localhost\n      ping:\n</code></pre>"},{"location":"Ansible/WSL/#52-run-the-playbook","title":"5.2 Run the Playbook","text":"<p>Run the playbook using the following command:</p> <pre><code>ansible-playbook test-playbook.yml\n</code></pre> <p>You should see a successful ping result, indicating that Ansible is working as expected.</p>"},{"location":"Ansible/WSL/#step-6-configure-ssh-for-remote-hosts-optional","title":"Step 6: Configure SSH for Remote Hosts (Optional)","text":"<p>Ansible typically runs commands on remote hosts over SSH. If you want to use Ansible to manage remote machines, you\u2019ll need to set up SSH access.</p> <ol> <li>Generate SSH keys:</li> </ol> <p><code>bash    ssh-keygen -t rsa</code></p> <ol> <li>Copy the public key to the remote machine:</li> </ol> <p><code>bash    ssh-copy-id user@remote-host-ip</code></p> <p>This allows you to connect to remote hosts without needing a password.</p> <p>Congratulations! You\u2019ve successfully set up Ansible on your Windows laptop using WSL. You can now automate tasks on both local and remote systems using Ansible\u2019s powerful automation capabilities. While WSL provides a seamless Linux environment, you can also explore using virtual machines or Docker for more isolated environments if needed.</p> <p>Feel free to expand your Ansible playbooks and start automating more complex tasks. Happy automating! \ud83d\udd28\ud83e\udd16</p>"},{"location":"Ansible/WSL/#additional-resources","title":"Additional Resources","text":"<ul> <li>Ansible Documentation</li> <li>WSL Documentation</li> <li>Install Ubuntu on WSL</li> </ul>"},{"location":"Docker/","title":"Docker","text":""},{"location":"Docker/#docker-command-cheat-sheet","title":"Docker Command Cheat Sheet","text":""},{"location":"Docker/#basic-commands","title":"Basic Commands","text":"<ul> <li> <p>Check Docker Version <code>bash   docker --version</code></p> </li> <li> <p>List Docker Images <code>bash   docker images</code></p> </li> <li> <p>List Running Containers <code>bash   docker ps</code></p> </li> <li> <p>List All Containers (including stopped) <code>bash   docker ps -a</code></p> </li> <li> <p>Run a Container <code>bash   docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p> </li> <li> <p>Stop a Running Container <code>bash   docker stop CONTAINER_ID</code></p> </li> <li> <p>Remove a Container <code>bash   docker rm CONTAINER_ID</code></p> </li> <li> <p>Remove an Image <code>bash   docker rmi IMAGE_ID</code></p> </li> </ul>"},{"location":"Docker/#building-docker-images","title":"Building Docker Images","text":"<ul> <li> <p>Build an Image from a Dockerfile <code>bash   docker build -t IMAGE_NAME:TAG PATH</code></p> </li> <li> <p>Build an Image from a Dockerfile (No Cache) <code>bash   docker build --no-cache -t IMAGE_NAME:TAG PATH</code></p> </li> <li> <p>View Build History <code>bash   docker history IMAGE_NAME:TAG</code></p> </li> </ul>"},{"location":"Docker/#dockerfile-basics","title":"Dockerfile Basics","text":"<ul> <li>Basic Dockerfile Structure   ```Dockerfile   # Use a base image   FROM ubuntu:latest</li> </ul> <p># Set environment variables   ENV VAR_NAME=value</p> <p># Install dependencies   RUN apt-get update &amp;&amp; apt-get install -y package</p> <p># Add files to the image   COPY local_path /container_path</p> <p># Set the working directory   WORKDIR /container_path</p> <p># Define the command to run   CMD [\"executable\", \"param1\", \"param2\"]   ```</p>"},{"location":"Docker/#networking-and-volumes","title":"Networking and Volumes","text":"<ul> <li> <p>Create a Network <code>bash   docker network create NETWORK_NAME</code></p> </li> <li> <p>Run a Container with a Network <code>bash   docker run --network NETWORK_NAME IMAGE_NAME</code></p> </li> <li> <p>Create a Volume <code>bash   docker volume create VOLUME_NAME</code></p> </li> <li> <p>Run a Container with a Volume <code>bash   docker run -v VOLUME_NAME:/container_path IMAGE_NAME</code></p> </li> </ul>"},{"location":"Docker/#docker-compose","title":"Docker Compose","text":"<ul> <li> <p>Start Services <code>bash   docker-compose up</code></p> </li> <li> <p>Start Services in Detached Mode <code>bash   docker-compose up -d</code></p> </li> <li> <p>Stop Services <code>bash   docker-compose down</code></p> </li> <li> <p>Build Services <code>bash   docker-compose build</code></p> </li> <li> <p>View Logs <code>bash   docker-compose logs</code></p> </li> </ul>"},{"location":"Docker/#pipeline-commands","title":"Pipeline Commands","text":"<ul> <li> <p>Push Image to Registry <code>bash   docker push IMAGE_NAME:TAG</code></p> </li> <li> <p>Pull Image from Registry <code>bash   docker pull IMAGE_NAME:TAG</code></p> </li> <li> <p>Tag an Image <code>bash   docker tag SOURCE_IMAGE:TAG TARGET_IMAGE:TAG</code></p> </li> <li> <p>Login to Docker Hub <code>bash   docker login</code></p> </li> <li> <p>Logout from Docker Hub <code>bash   docker logout</code></p> </li> </ul>"},{"location":"Jenkins/","title":"Jenkins","text":"<p>Bash script that automates the installation of Jenkins, sets up Java, enables and starts the Jenkins service, and configures the firewall on an Ubuntu system.  It also retrieves and prints the initial Jenkins password and the IP address along with the port number.</p> <pre><code>#!/bin/bash\n\n# Function to print messages\nprint_message() {\n    echo \"==================================================\"\n    echo \"$1\"\n    echo \"==================================================\"\n}\n\n# Update system\nprint_message \"Updating system packages...\"\nsudo apt-get update -y\n\n# Install Java\nprint_message \"Installing OpenJDK 17...\"\nsudo apt-get install -y fontconfig openjdk-17-jre\n\n# Verify Java installation\nprint_message \"Verifying Java installation...\"\njava -version\n\n# Add Jenkins key and repository\nprint_message \"Adding Jenkins repository and key...\"\nsudo wget -O /usr/share/keyrings/jenkins-keyring.asc https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key\necho \"deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/\" | sudo tee /etc/apt/sources.list.d/jenkins.list &gt; /dev/null\n\n# Update system again\nprint_message \"Updating system packages again...\"\nsudo apt-get update -y\n\n# Install Jenkins\nprint_message \"Installing Jenkins...\"\nsudo apt-get install -y jenkins\n\n# Enable Jenkins service\nprint_message \"Enabling Jenkins service...\"\nsudo systemctl enable jenkins\n\n# Start Jenkins service\nprint_message \"Starting Jenkins service...\"\nsudo systemctl start jenkins\n\n# Check Jenkins service status\nprint_message \"Checking Jenkins service status...\"\nsudo systemctl status jenkins\n\n# Configure firewall\nprint_message \"Configuring firewall to allow Jenkins...\"\nsudo ufw allow 8080\nsudo ufw enable\n\n# Print IP address and port\nprint_message \"Printing IP address and port...\"\nIP_ADDRESS=$(hostname -I | awk '{print $1}')\nPORT=8080\necho \"Jenkins is running on http://$IP_ADDRESS:$PORT\"\n\n# Retrieve and print the Jenkins initial password\nprint_message \"Retrieving Jenkins initial admin password...\"\nINITIAL_PASSWORD=$(sudo cat /var/lib/jenkins/secrets/initialAdminPassword)\necho \"Initial Admin Password: $INITIAL_PASSWORD\"\n\nprint_message \"Jenkins installation and setup completed successfully!\"\n</code></pre> <p>To use this script:</p> <ol> <li>Save the script to a file, for example, <code>install_jenkins.sh</code>.</li> <li>Make the script executable: <code>chmod +x install_jenkins.sh</code></li> <li>Run the script with sudo privileges: <code>sudo ./install_jenkins.sh</code></li> </ol>"},{"location":"Jenkins/CICD/docker_jenkins_sonarqube/","title":"Docker jenkins sonarqube","text":"<p>To set up Jenkins, SonarQube, and Nginx on an Ubuntu system using Docker and Docker Compose, you'll need to create a <code>Dockerfile</code> for each service (if necessary) and a <code>docker-compose.yml</code> file to manage and run all the services together. Below is a step-by-step guide to achieve this:</p>"},{"location":"Jenkins/CICD/docker_jenkins_sonarqube/#step-1-install-docker-and-docker-compose","title":"Step 1: Install Docker and Docker Compose","text":"<p>First, ensure you have Docker and Docker Compose installed on your Ubuntu system.</p> <pre><code>sudo apt update\nsudo apt install -y docker.io\nsudo systemctl start docker\nsudo systemctl enable docker\n\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\n</code></pre>"},{"location":"Jenkins/CICD/docker_jenkins_sonarqube/#step-2-create-docker-compose-file","title":"Step 2: Create Docker Compose File","text":"<p>Create a directory for your project and navigate to it:</p> <pre><code>mkdir jenkins-sonarqube-nginx\ncd jenkins-sonarqube-nginx\n</code></pre> <p>Create a <code>docker-compose.yml</code> file in this directory with the following content:</p> <pre><code>version: '3'\n\nservices:\n  jenkins:\n    image: jenkins/jenkins:lts\n    container_name: jenkins\n    ports:\n      - \"8080:8080\"\n      - \"50000:50000\"\n    volumes:\n      - jenkins_home:/var/jenkins_home\n\n  sonarqube:\n    image: sonarqube:latest\n    container_name: sonarqube\n    ports:\n      - \"9000:9000\"\n    environment:\n      - SONARQUBE_JDBC_URL=jdbc:postgresql://db:5432/sonar\n      - SONARQUBE_JDBC_USERNAME=sonar\n      - SONARQUBE_JDBC_PASSWORD=sonar\n    depends_on:\n      - db\n\n  db:\n    image: postgres:latest\n    container_name: db\n    environment:\n      - POSTGRES_USER=sonar\n      - POSTGRES_PASSWORD=sonar\n      - POSTGRES_DB=sonar\n    volumes:\n      - db_data:/var/lib/postgresql/data\n\n  nginx:\n    image: nginx:latest\n    container_name: nginx\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n\nvolumes:\n  jenkins_home:\n  db_data:\n</code></pre>"},{"location":"Jenkins/CICD/docker_jenkins_sonarqube/#step-3-configure-nginx","title":"Step 3: Configure Nginx","text":"<p>Create an <code>nginx.conf</code> file in the same directory with the following content to reverse proxy to Jenkins and SonarQube:</p> <pre><code>worker_processes 1;\n\nevents { worker_connections 1024; }\n\nhttp {\n    sendfile on;\n\n    upstream jenkins {\n        server jenkins:8080;\n    }\n\n    upstream sonarqube {\n        server sonarqube:9000;\n    }\n\n    server {\n        listen 80;\n\n        location /jenkins/ {\n            proxy_pass http://jenkins/;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_redirect http://jenkins/ /jenkins/;\n        }\n\n        location /sonarqube/ {\n            proxy_pass http://sonarqube/;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            proxy_redirect http://sonarqube/ /sonarqube/;\n        }\n    }\n}\n</code></pre>"},{"location":"Jenkins/CICD/docker_jenkins_sonarqube/#step-4-start-the-services","title":"Step 4: Start the Services","text":"<p>Now, start the services using Docker Compose:</p> <pre><code>sudo docker-compose up -d\n</code></pre> <p>This will start Jenkins on port 8080, SonarQube on port 9000, and Nginx on port 80. You can access Jenkins at <code>http://&lt;your_server_ip&gt;/jenkins/</code> and SonarQube at <code>http://&lt;your_server_ip&gt;/sonarqube/</code>.</p>"},{"location":"Jenkins/CICD/docker_jenkins_sonarqube/#step-5-configure-jenkins-and-sonarqube","title":"Step 5: Configure Jenkins and SonarQube","text":"<ul> <li>Access Jenkins at <code>http://&lt;your_server_ip&gt;/jenkins/</code> and follow the initial setup instructions.</li> <li>Access SonarQube at <code>http://&lt;your_server_ip&gt;/sonarqube/</code> and follow the initial setup instructions.</li> </ul>"},{"location":"Jenkins/CICD/docker_jenkins_sonarqube/#optional-persistent-data","title":"Optional: Persistent Data","text":"<p>If you want to persist Jenkins and PostgreSQL data across container restarts, the <code>volumes</code> configuration in the <code>docker-compose.yml</code> file takes care of that.</p> <p>That's it! You have successfully set up Jenkins, SonarQube, and Nginx using Docker and Docker Compose on an Ubuntu system.</p>"},{"location":"Jenkins/Java%20App/Java_Project/","title":"Java Project","text":"<p>To create a Java project, set it up for testing with Jenkins, and save all the code on GitHub, follow these steps:</p>"},{"location":"Jenkins/Java%20App/Java_Project/#step-1-set-up-the-java-project","title":"Step 1: Set Up the Java Project","text":"<ol> <li> <p>Install Java Development Kit (JDK):    Make sure you have JDK installed on your system. You can download it from Oracle's website.</p> </li> <li> <p>Create a new Java project:    Use an IDE like IntelliJ IDEA, Eclipse, or create the project manually.</p> </li> </ol> <p>Here's a simple structure for a Maven project:</p> <p><code>MyJavaProject    \u251c\u2500\u2500 src    \u2502   \u2514\u2500\u2500 main    \u2502       \u2514\u2500\u2500 java    \u2502           \u2514\u2500\u2500 com    \u2502               \u2514\u2500\u2500 example    \u2502                   \u2514\u2500\u2500 App.java    \u251c\u2500\u2500 pom.xml    \u2514\u2500\u2500 README.md</code></p> <ol> <li>pom.xml:    Create a <code>pom.xml</code> file for Maven dependencies.</li> </ol> <p><code>xml    &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"             xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;        &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;        &lt;groupId&gt;com.example&lt;/groupId&gt;        &lt;artifactId&gt;MyJavaProject&lt;/artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;properties&gt;            &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;            &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;        &lt;/properties&gt;        &lt;dependencies&gt;            &lt;!-- JUnit 5 dependency for testing --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;                &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;                &lt;version&gt;5.7.0&lt;/version&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;        &lt;build&gt;            &lt;plugins&gt;                &lt;plugin&gt;                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                    &lt;version&gt;2.22.2&lt;/version&gt;                &lt;/plugin&gt;            &lt;/plugins&gt;        &lt;/build&gt;    &lt;/project&gt;</code></p> <ol> <li>App.java:    Create a simple Java application.</li> </ol> <p>```java    package com.example;</p> <p>public class App {        public static void main(String[] args) {            System.out.println(\"Hello, World!\");        }    }    ```</p> <ol> <li>Unit Test:    Create a test for the application.</li> </ol> <p>```java    package com.example;</p> <p>import org.junit.jupiter.api.Test;    import static org.junit.jupiter.api.Assertions.assertEquals;</p> <p>public class AppTest {        @Test        public void testApp() {            assertEquals(1, 1); // Simple test        }    }    ```</p>"},{"location":"Jenkins/Java%20App/Java_Project/#step-2-set-up-jenkins","title":"Step 2: Set Up Jenkins","text":"<ol> <li> <p>Install Jenkins:    Download and install Jenkins from the official website.</p> </li> <li> <p>Configure Jenkins:</p> </li> <li>Create a new Jenkins job (Freestyle or Pipeline).</li> <li> <p>Set up the SCM to use Git and provide the GitHub repository URL.</p> </li> <li> <p>Jenkins Pipeline Script (if using a Pipeline job):    <code>groovy    pipeline {        agent any        tools {            maven 'Maven 3.6.3' // Adjust based on your Maven installation            jdk 'JDK 11' // Adjust based on your JDK installation        }        stages {            stage('Checkout') {                steps {                    git 'https://github.com/yourusername/MyJavaProject.git'                }            }            stage('Build') {                steps {                    sh 'mvn clean package'                }            }            stage('Test') {                steps {                    sh 'mvn test'                }            }        }    }</code></p> </li> </ol>"},{"location":"Jenkins/Java%20App/Java_Project/#step-3-save-the-code-on-github","title":"Step 3: Save the Code on GitHub","text":"<ol> <li>Create a new repository on GitHub:</li> <li> <p>Go to GitHub and create a new repository.</p> </li> <li> <p>Push the code to GitHub:    <code>bash    cd MyJavaProject    git init    git remote add origin https://github.com/yourusername/MyJavaProject.git    git add .    git commit -m \"Initial commit\"    git push -u origin master</code></p> </li> </ol>"},{"location":"Jenkins/Java%20App/Java_Project/#summary","title":"Summary","text":"<ol> <li>Set up a Maven-based Java project.</li> <li>Write a simple Java application and a unit test.</li> <li>Install and configure Jenkins to build and test the project.</li> <li>Create a repository on GitHub and push your code to it.</li> </ol> <p>Once these steps are complete, you should have a Java project in GitHub that Jenkins can pull, build, and test.</p>"},{"location":"Kubernetes/","title":"Mastering Kubernetes: From Introduction to Deploying NGINX","text":"<p>Kubernetes is a powerful tool that helps manage and run applications in containers. It makes tasks like deploying, scaling, and maintaining apps much easier. This guide will help you learn the basics of Kubernetes, set it up in Docker Desktop, use <code>kubectl</code>, and deploy NGINX.</p>"},{"location":"Kubernetes/#what-is-kubernetes","title":"What is Kubernetes?","text":"<p>Kubernetes is a free, open-source system that helps automate the management of applications in containers. It simplifies the deployment and operation of applications by handling the underlying infrastructure for you. Here\u2019s a quick look at its main features:</p>"},{"location":"Kubernetes/#key-concepts","title":"Key Concepts","text":"<ol> <li>Pod:</li> <li>What It Is: The smallest unit in Kubernetes. A Pod can hold one or more containers that share the same network and storage.</li> <li> <p>What It Does: Runs single instances of applications or services, keeping them consistent and separate from others.</p> </li> <li> <p>Deployment:</p> </li> <li>What It Is: Manages how Pods are deployed and scaled. It ensures that the right number of Pods are running and helps with updates.</li> <li> <p>What It Does: Automates creating, updating, and scaling Pods, making sure your app is always available.</p> </li> <li> <p>Service:</p> </li> <li>What It Is: Defines a way to access a set of Pods and provides a stable network address.</li> <li> <p>What It Does: Helps with load balancing and finding services, ensuring reliable communication between app parts.</p> </li> <li> <p>ReplicaSet:</p> </li> <li>What It Is: Ensures a specified number of Pod copies are running. Usually managed by Deployments.</li> <li> <p>What It Does: Keeps your app reliable and scalable by maintaining the right number of Pod copies.</p> </li> <li> <p>Namespace:</p> </li> <li>What It Is: Divides cluster resources into virtual clusters to organize and control access.</li> <li>What It Does: Useful for separating environments like development and production, or for managing different projects.</li> </ol>"},{"location":"Kubernetes/#setting-up-kubernetes-in-docker-desktop","title":"Setting Up Kubernetes in Docker Desktop","text":"<p>Docker Desktop includes a built-in Kubernetes cluster for local development. Here\u2019s how to set it up:</p> <ol> <li>Open Docker Desktop:</li> <li> <p>Start Docker Desktop from your applications menu.</p> </li> <li> <p>Go to Settings:</p> </li> <li> <p>Click the gear icon (\u2699\ufe0f) in the top-right corner.</p> </li> <li> <p>Select the Kubernetes Tab:</p> </li> <li> <p>Choose the \"Kubernetes\" tab from the sidebar.</p> </li> <li> <p>Enable Kubernetes:</p> </li> <li> <p>Check \"Enable Kubernetes\".</p> </li> <li> <p>Apply &amp; Restart:</p> </li> <li> <p>Click \"Apply &amp; Restart\" to start Kubernetes. Docker Desktop will restart to configure it.</p> </li> <li> <p>Wait for Setup:</p> </li> <li>It might take a few minutes for Kubernetes to start. Docker Desktop will show the setup status.</li> </ol>"},{"location":"Kubernetes/#what-is-kubectl","title":"What is <code>kubectl</code>?","text":"<p><code>kubectl</code> is a command-line tool for managing Kubernetes clusters. It lets you interact with your Kubernetes resources.</p>"},{"location":"Kubernetes/#key-features-of-kubectl","title":"Key Features of <code>kubectl</code>:","text":"<ul> <li>Run Commands: Manage resources like Pods, Services, and Deployments.</li> <li>Change Configurations: Apply changes to create or update resources.</li> <li>Check Status: View and debug the state of resources in the cluster.</li> </ul>"},{"location":"Kubernetes/#common-kubectl-commands","title":"Common <code>kubectl</code> Commands:","text":"<ul> <li>Get Resources:   <code>bash   kubectl get [resource]</code></li> <li> <p>Lists resources like Pods, Services, or Deployments.</p> </li> <li> <p>Describe Resource:   <code>bash   kubectl describe [resource] [name]</code></p> </li> <li> <p>Shows detailed info about a specific resource.</p> </li> <li> <p>Apply Configuration:   <code>bash   kubectl apply -f [file.yaml]</code></p> </li> <li> <p>Applies changes from a YAML file.</p> </li> <li> <p>Delete Resource:   <code>bash   kubectl delete -f [file.yaml]</code></p> </li> <li>Deletes resources from the cluster. -If you want to delete all the pods in a namespace, use:</li> </ul> <pre><code>kubectl delete pods --all\n</code></pre> <p>-To delete all services in the current namespace, use:</p> <pre><code>kubectl delete services --all\n</code></pre>"},{"location":"Kubernetes/#checking-versions","title":"Checking Versions","text":""},{"location":"Kubernetes/#check-kubectl-version","title":"Check <code>kubectl</code> Version","text":"<p>To find out which version of <code>kubectl</code> you have:</p> <pre><code>kubectl version --client\n</code></pre> <pre><code>kubectl version\n</code></pre> <ul> <li>This shows both the client and server versions of Kubernetes.</li> </ul>"},{"location":"Kubernetes/#deploying-nginx-instances","title":"Deploying NGINX Instances","text":"<p>To deploy multiple NGINX instances, follow these steps:</p>"},{"location":"Kubernetes/#step-1-create-a-deployment","title":"Step 1: Create a Deployment","text":"<ol> <li>Open Terminal:</li> <li> <p>Use your terminal or command prompt.</p> </li> <li> <p>Create Deployment YAML File:</p> </li> <li>Save the following to <code>nginx-deployment.yaml</code>:</li> </ol> <p><code>yaml    apiVersion: apps/v1    kind: Deployment    metadata:      name: nginx-deployment    spec:      replicas: 3      selector:        matchLabels:          app: nginx      template:        metadata:          labels:            app: nginx        spec:          containers:          - name: nginx            image: nginx:latest            ports:            - containerPort: 80</code></p> <ul> <li> <p>What It Does: Defines a Deployment with 3 replicas of NGINX.</p> </li> <li> <p>Apply the Deployment:</p> </li> <li>Run:</li> </ul> <p><code>bash    kubectl apply -f nginx-deployment.yaml</code></p>"},{"location":"Kubernetes/#step-2-expose-the-deployment","title":"Step 2: Expose the Deployment","text":"<ol> <li>Create Service YAML File:</li> <li>Save the following to <code>nginx-service.yaml</code>:</li> </ol> <p><code>yaml    apiVersion: v1    kind: Service    metadata:      name: nginx-service    spec:      selector:        app: nginx      ports:        - protocol: TCP          port: 80          targetPort: 80      type: LoadBalancer</code></p> <ul> <li> <p>What It Does: Creates a Service to expose the NGINX Deployment.</p> </li> <li> <p>Apply the Service:</p> </li> <li>Run:</li> </ul> <p><code>bash    kubectl apply -f nginx-service.yaml</code></p> <ol> <li>Access NGINX in Browser:</li> <li>Open:</li> </ol> <p><code>bash    http://127.0.0.1/</code></p>"},{"location":"Kubernetes/#step-3-check-the-status","title":"Step 3: Check the Status","text":"<ol> <li>List Pods:</li> <li>Check Pods:</li> </ol> <p><code>bash    kubectl get pods</code></p> <ol> <li>Check Deployment:</li> <li>Verify Deployment:</li> </ol> <p><code>bash    kubectl get deployments</code></p> <ol> <li>Check Service:</li> <li>View Service status:</li> </ol> <p><code>bash    kubectl get services</code></p> <ul> <li>Note: Docker Desktop has a Kubernetes dashboard for a visual view of your resources.</li> </ul>"},{"location":"Kubernetes/#step-4-clean-up","title":"Step 4: Clean Up","text":"<ol> <li>Delete the Service:</li> </ol> <p><code>bash    kubectl delete -f nginx-service.yaml</code></p> <ol> <li>Delete the Deployment:</li> </ol> <p><code>bash    kubectl delete -f nginx-deployment.yaml</code></p> <ol> <li>Verify Deletion:</li> <li>Ensure Pods and Services are removed:</li> </ol> <p><code>bash    kubectl get pods    kubectl get services</code></p>"},{"location":"Kubernetes/Installation/install_k8s_tools/","title":"Install k8s tools","text":"<p>Shell script that automates the installation of <code>kubectl</code>, <code>minikube</code>, and <code>docker</code> on Ubuntu 22.04 (Jammy Jellyfish):</p> <pre><code>#!/bin/bash\n\n# Update system packages\nsudo apt-get update -y\nsudo apt-get upgrade -y\n\n# Install Docker\nsudo apt-get remove docker docker-engine docker.io containerd runc -y\nsudo apt-get update -y\nsudo apt-get install ca-certificates curl gnupg lsb-release -y\n\n# Add Docker's official GPG key\nsudo mkdir -m 0755 -p /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n# Set up the Docker repository\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n# Install Docker Engine\nsudo apt-get update -y\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y\n\n# Start and enable Docker\nsudo systemctl start docker\nsudo systemctl enable docker\n\n# Add your user to the docker group\nsudo usermod -aG docker $USER\n\n# Install kubectl\nsudo apt-get update -y\nsudo apt-get install -y apt-transport-https ca-certificates curl\nsudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg\necho \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list\nsudo apt-get update -y\nsudo apt-get install -y kubectl\n\n# Install Minikube\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube\nrm minikube-linux-amd64\n\n# Print installation versions\necho \"Docker version:\"\ndocker --version\necho \"kubectl version:\"\nkubectl version --client\necho \"Minikube version:\"\nminikube version\n\necho \"Installation complete. Please log out and log back in to apply the Docker group membership.\"\n</code></pre>"},{"location":"Kubernetes/Installation/install_k8s_tools/#instructions-to-run-the-script","title":"Instructions to Run the Script","text":"<ol> <li>Save the script to a file, for example <code>install_k8s_tools.sh</code>.</li> <li>Make the script executable:     <code>bash     chmod +x install_k8s_tools.sh</code></li> <li>Run the script:     <code>bash     ./install_k8s_tools.sh</code></li> </ol> <p>This script will:</p> <ul> <li>Update and upgrade the system packages.</li> <li>Install Docker and add the current user to the <code>docker</code> group.</li> <li>Install <code>kubectl</code> from the Kubernetes APT repository.</li> <li>Install the latest version of <code>minikube</code>.</li> </ul> <p>After running the script, log out and log back in to apply the Docker group membership changes.  </p>"},{"location":"Kubernetes/Installation/k8sinstall_script/","title":"K8sinstall script","text":"<p>Here is a shell script to automate the setup of a Kubernetes 1.27 cluster using <code>kubeadm</code>, excluding the step to join the worker nodes to the cluster. This script should be run on all nodes (control plane and workers) to prepare them for the Kubernetes setup.</p> <pre><code>#!/bin/bash\n\n# Exit immediately if a command exits with a non-zero status.\nset -e\n\n# Step 1: Initial Setup on All Nodes\n\n# Create configuration file for containerd\ncat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf\noverlay\nbr_netfilter\nEOF\n\n# Load the necessary modules\nsudo modprobe overlay\nsudo modprobe br_netfilter\n\n# Set system configurations for Kubernetes networking\ncat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf\nnet.bridge.bridge-nf-call-iptables = 1\nnet.ipv4.ip_forward = 1\nnet.bridge.bridge-nf-call-ip6tables = 1\nEOF\n\n# Apply the new settings\nsudo sysctl --system\n\n# Install containerd\nsudo apt-get update\nsudo apt-get install -y containerd.io\n\n# Create the default configuration file for containerd\nsudo mkdir -p /etc/containerd\nsudo containerd config default | sudo tee /etc/containerd/config.toml\n\n# Restart containerd to ensure the new configuration file is used\nsudo systemctl restart containerd\n\n# Verify that containerd is running\nsudo systemctl status containerd\n\n# Disable swap\nsudo swapoff -a\n\n# Install dependency packages\nsudo apt-get install -y apt-transport-https curl\n\n# Download and add the GPG key\nsudo mkdir -p /etc/apt/keyrings\ncurl -fsSL https://pkgs.k8s.io/core:/stable:/v1.27/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg\n\n# Add Kubernetes to the repository list\ncat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list\ndeb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.27/deb/ /\nEOF\n\n# Update the package listings\nsudo apt-get update\n\n# Install Kubernetes packages\nsudo apt-get install -y kubelet kubeadm kubectl\n\n# Turn off automatic updates for Kubernetes packages\nsudo apt-mark hold kubelet kubeadm kubectl\n\n# If this is the control plane node, initialize the Kubernetes cluster\nif [[ $(hostname) == \"k8s-control\" ]]; then\n    sudo kubeadm init --pod-network-cidr 192.168.0.0/16 --kubernetes-version 1.27.11\n\n    # Set up kubectl for the control plane node\n    mkdir -p $HOME/.kube\n    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n    sudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n    # Install Calico Networking\n    kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/calico.yaml\n\n    # Verify the installation\n    kubectl get nodes\nfi\n</code></pre> <p>Instructions: 1. Save the script to a file, for example <code>setup_k8s_cluster.sh</code>. 2. Make the script executable:</p> <pre><code>```sh\nchmod +x setup_k8s_cluster.sh\n```\n</code></pre> <ol> <li> <p>Run the script on all nodes:</p> <p><code>sh ./setup_k8s_cluster.sh</code></p> </li> <li> <p>For the control plane node, set the hostname to <code>k8s-control</code> before running the script:</p> <p><code>sh sudo hostnamectl set-hostname k8s-control</code></p> </li> <li> <p>Similarly, set the hostnames for the worker nodes (<code>k8s-worker1</code>, <code>k8s-worker2</code>) before running the script on them.</p> </li> </ol>"},{"location":"Linux/https/","title":"How to Secure Your Website with HTTPS: A Step-by-Step Guide for Apache and Nginx","text":""},{"location":"Linux/https/#introduction","title":"Introduction","text":"<p>In today\u2019s digital landscape, securing your website is more important than ever. HTTPS (Hypertext Transfer Protocol Secure) ensures that data exchanged between your web server and visitors is encrypted and secure. This guide will walk you through the process of setting up HTTPS on Apache and Nginx servers, including key concepts like SSL, OpenSSL, and certificate management.</p>"},{"location":"Linux/https/#what-is-ssl","title":"What is SSL?","text":"<p>SSL (Secure Sockets Layer) is a protocol designed to provide secure communication over a network. Although SSL has largely been replaced by TLS (Transport Layer Security), the term SSL is still commonly used. SSL/TLS encrypts data exchanged between a web server and a client (e.g., a web browser), ensuring that sensitive information remains private and secure.</p>"},{"location":"Linux/https/#what-is-https","title":"What is HTTPS?","text":"<p>HTTPS (Hypertext Transfer Protocol Secure) is an extension of HTTP that uses SSL/TLS to encrypt data exchanged between a web server and a client. When you see \"https://\" in your browser\u2019s address bar, it indicates that the connection is secure and that data is encrypted.</p>"},{"location":"Linux/https/#what-is-openssl","title":"What is OpenSSL?","text":"<p>OpenSSL is an open-source toolkit that provides libraries and tools for working with SSL/TLS protocols. It is used to generate and manage certificates and keys, allowing you to secure your communications effectively.</p>"},{"location":"Linux/https/#understanding-certificate-files","title":"Understanding Certificate Files","text":"<ol> <li> <p>.crt File: Contains the public key and information about the certificate. This file is issued by a Certificate Authority (CA) and is used to verify the identity of your server.</p> </li> <li> <p>.pem File: A versatile file format that can include certificates, private keys, and other data. PEM stands for Privacy Enhanced Mail.</p> </li> <li> <p>.csr File: The Certificate Signing Request (CSR) is created when you want to obtain a certificate from a CA. It includes your public key and details about your organization.</p> </li> <li> <p>Private Key: A confidential key used to encrypt data sent from the server. It must be kept secure and private.</p> </li> </ol>"},{"location":"Linux/https/#step-by-step-guide-to-installing-https","title":"Step-by-Step Guide to Installing HTTPS","text":""},{"location":"Linux/https/#1-preparing-for-https-installation","title":"1. Preparing for HTTPS Installation","text":"<ul> <li>Obtain a Domain Name: Ensure you have a fully qualified domain name (FQDN) for your server.</li> <li>Access to a Server: You need root or administrative access to your server.</li> </ul>"},{"location":"Linux/https/#2-generate-a-private-key-and-csr","title":"2. Generate a Private Key and CSR","text":"<ul> <li>Generate a Private Key:   <code>bash   openssl genpkey -algorithm RSA -out /etc/ssl/private/private.key -aes256</code></li> <li> <p>Use the <code>-aes256</code> option to encrypt the private key with a passphrase. If you prefer an unencrypted key, omit this option.</p> </li> <li> <p>Create a Certificate Signing Request (CSR):   <code>bash   openssl req -new -key /etc/ssl/private/private.key -out /etc/ssl/private/request.csr</code></p> </li> <li>During CSR generation, you will be asked for details like your country, state, and domain name.</li> </ul>"},{"location":"Linux/https/#3-obtain-and-install-a-certificate","title":"3. Obtain and Install a Certificate","text":"<ul> <li> <p>Submit the CSR to Your CA: The CA will provide you with a certificate file (<code>certificate.crt</code>). You might also receive a CA bundle file containing intermediate certificates.</p> </li> <li> <p>Combine Certificate and Key (Optional):   If necessary, combine your certificate and private key into a single PEM file:   <code>bash   cat /etc/ssl/certs/certificate.crt /etc/ssl/certs/ca_bundle.crt &gt; /etc/ssl/certs/fullchain.pem</code></p> </li> </ul>"},{"location":"Linux/https/#4-configure-apache","title":"4. Configure Apache","text":"<ul> <li> <p>Move Certificates: Place your certificate files in a secure directory, e.g., <code>/etc/ssl/certs/</code>.</p> </li> <li> <p>Update Apache Configuration:   Edit the SSL configuration file (usually located at <code>/etc/httpd/conf.d/ssl.conf</code> or <code>/etc/apache2/sites-available/default-ssl.conf</code>). Ensure the following settings are correct:   <code>apache   SSLEngine on   SSLCertificateFile /etc/ssl/certs/certificate.crt   SSLCertificateKeyFile /etc/ssl/private/private.key   SSLCertificateChainFile /etc/ssl/certs/ca_bundle.crt</code></p> </li> <li> <p>Use <code>SSLCertificateChainFile</code> if you have intermediate certificates.</p> </li> <li> <p>Set Permissions:   Secure the private key:   <code>bash   chmod 600 /etc/ssl/private/private.key</code></p> </li> <li> <p>Enable SSL Module (if not enabled):   <code>bash   a2enmod ssl</code></p> </li> <li> <p>Restart Apache:   <code>bash   sudo systemctl restart apache2</code></p> </li> </ul>"},{"location":"Linux/https/#5-configure-nginx","title":"5. Configure Nginx","text":"<ul> <li> <p>Move Certificates: Place your certificate files in a secure directory, e.g., <code>/etc/nginx/ssl/</code>.</p> </li> <li> <p>Update Nginx Configuration:   Edit your server block configuration file (usually in <code>/etc/nginx/sites-available/default</code> or a similar file):   ```nginx   server {       listen 443 ssl;       server_name yourdomain.com;</p> <p>ssl_certificate /etc/nginx/ssl/certificate.crt;   ssl_certificate_key /etc/nginx/ssl/private.key;   ssl_certificate /etc/nginx/ssl/fullchain.pem; # If combining with chain file</p> <p>ssl_protocols TLSv1.2 TLSv1.3;   ssl_ciphers HIGH:!aNULL:!MD5;</p> <p>location / {       proxy_pass http://localhost:8080;       proxy_set_header Host $host;       proxy_set_header X-Real-IP $remote_addr;       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;       proxy_set_header X-Forwarded-Proto $scheme;   }   }   ```</p> </li> <li> <p>Set Permissions:   Secure the private key:   <code>bash   chmod 600 /etc/nginx/ssl/private.key</code></p> </li> <li> <p>Restart Nginx:   <code>bash   sudo systemctl restart nginx</code></p> </li> </ul>"},{"location":"Linux/https/#6-verify-installation","title":"6. Verify Installation","text":"<ul> <li> <p>Check HTTPS Connection:   Visit your website and verify that you see the padlock icon in the browser's address bar.</p> </li> <li> <p>Using OpenSSL to Verify:   <code>bash   openssl s_client -connect yourdomain.com:443</code>   This command will show you the certificate chain and connection details.</p> </li> <li> <p>Check Certificate Expiry:   <code>bash   openssl x509 -in /etc/ssl/certs/certificate.crt -noout -enddate</code></p> </li> </ul>"},{"location":"Linux/https/#7-configure-hsts","title":"7. Configure HSTS","text":"<ul> <li> <p>For Apache:   Add the following line to your SSL configuration file:   <code>apache   Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"</code></p> </li> <li> <p>For Nginx:   Add the following line to your server block configuration:   <code>nginx   add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\";</code></p> </li> </ul>"},{"location":"Linux/https/#8-understanding-reverse-proxy","title":"8. Understanding Reverse Proxy","text":"<ul> <li> <p>Reverse Proxy: A reverse proxy forwards client requests to a backend server and sends responses back to the clients. It can handle SSL termination, meaning it manages the SSL/TLS connection on behalf of the backend server, which only sees plain HTTP traffic.</p> </li> <li> <p>Use Case:</p> </li> <li>Load Balancing: Distributes traffic across multiple backend servers.</li> <li>Caching: Stores copies of frequently requested content to improve performance.</li> <li> <p>Security: Hides the details of your backend servers from the public.</p> </li> <li> <p>Configuring Reverse Proxy:</p> </li> <li>For Nginx: Use the <code>proxy_pass</code> directive as shown in the Nginx configuration above.</li> <li>For Apache: Use <code>ProxyPass</code> and <code>ProxyPassReverse</code> directives in your configuration.</li> </ul>"},{"location":"blog/","title":"Blog","text":""}]}